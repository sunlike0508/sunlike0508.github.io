---
title:  "자바 개념공부 08"
excerpt: "JVM/JRE/JDK"
classes: wide
categories:
  - java
tags:
  - [java, JVM, JRE, JDK]
last_modified_at: 2020-04-16
---

# JVM, JRE, JDK

*Java를 실행시키기 위해선 JVM, JRE, JDK 세 가지가  모두 필요하다. 일반적으로 JDK를 설치하면 다 포함.

JRE만 있어도 프로그램을 구동시킬수는 있다.

*세 가지의 구성은 다음 그림과 같다.

![]({{site.url}}/assets/images/jvm.jpg)



## JDK (Java Development Kit)

*개발도구

*JRE와 개발용 라이브러리를 포함



## JRE (Java Runtime Environment)

*JVM용 운영체제(소프트웨어 역할)

*JVM이 자바 프로그램을 실행하기 위해 필요한 라이브러리와 파일을 가지고 있다.

* API는 JDK보다 크지만 JRE보다 작다

## JVM (Java Virtual Machine)

*자바 가상 머신(하드웨어 역할)

*파일명.java 들을 컴파일한 파일명.class 들을 실행

*플랫폼에 의존적(window, mac, linux etc)

*JVM의 실행 단계는 다음 그림과 같다.

![]({{site.url}}/assets/images/jvm.png)



### Class Loader

1.자바 프로그램을 실행하면 컴파일러가 .java 파일을 .class 파일로 변환시킨다.

2.class loader는 .class 파일을 runtime(실행)하는 시점에 runtime data areas로 로딩

*이때 모든 class가 참조되는 순간 동적으로 load과 link가 이루어짐. 이를 다이나믹 로딩이라함.

(뭐라고 하는거냐;;;)



### Runtime Data Areas

*런타임 데이터 영역은 JVM이 실행될 때 할당 받는 메모리 영역

![]({{site.url}}/assets/images/runtime.png)



### Thread (Java Threads)

*스레드가 시작될때마다 생성

*아래는 thread의 구성이다.

#### 1. PC Register

*현재 실행중인 JVM 명령의 주소가 저장

*연산을 위해 필요한 피연산자를 임시로 저장하기 위해 사용

#### 2. JVM Stack

*stack fram을 저장. 

#### 3. Native method stack

*자바 외의 언러로 작성된 native 코드를 위한 스택. 

*JNI(java native interface)를 통해 호출하는 C/C++등의 코드를 수행하기 위한 스택



### Heap

*인스턴스(객체)를 저장하는 공간

*GC의 대상

*성능 이슈를 일으키는 공간



### Method area

*JVM이 읽어드린 각 클래스, 인터페이스에 대한 runtime constant pool. 필드, 메서드 정보, static 변수,

메서드의 바이트 코드 등을 저장.

*이를 바탕으로 heap 영역에 객체를 생성



<<program counter registers과 native internal threads는 설명 생략>>



### Execution Engine

#### 1.Interpreter 

*바이트코드 명령어를 하나씩 읽어서 해석하고 실행

*하나씩 하기 때문에 해석은 빠르나 실행이 느림

#### 2. JIT(Just-in-time)

*인터프리터 단점을 보완하기 위해 만들어짐

*인터프리터 방식으로 실행하다가 적절한 시점에 바이트코드 전체를 컴파일하여 네이티브 코드로 변경. 이후에는 해당 메서드를 더 이상 인터프리팅하지 않고 네이티브 코드로 직접 실행하는 방식.