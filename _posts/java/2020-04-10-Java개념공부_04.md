---
title:  "자바 개념공부 03"
excerpt: "String&StringBuffer&StringBuilder"
classes: wide
categories:
  - java
tags:
  - java
  - String
  - StringBuffer
  - StringBuilder
last_modified_at: 2020-04-10
---

#### **String**&StringBuffer&StringBuilder



**String과 StringBuffer/StringBuilder의 차이점**

*가장 큰 차이점은 String은 불변(immutable)이라는 점.  읽는 경우는 성능이 좋으나 연산의 경우 좋지 않음

```java
String str = "hello";   // String str = new String("hello");
str = str + " world";  // [ hello world ]
```

![](C:\Users\user\Desktop\myBlog\sunlike0508.github.io\assets\images\kadane.PNG)



*Sql 작성할 때 유용하다.

```java
/* 예시 1 */
String[] param = new String[] {" 1", "100", "154","155","21"};
String paramforIn = String.join(",", param);

StringBuilder sql = new StringBuilder();

sql.append("Select * from raw_contacts where _id in (").append(paramforIn).append(")");

System.out.println(sql.toString());
//결과 값 : Select * from raw_contacts where _id in (1,100,154,155,21)

/* 예시 2 */
String[] names = new String[] {"홍길동", "임꺽정", "슈퍼맨", "배트맨", "아이언맨" };
List<String> nameList = Arrays.asList(names);
String sql1 = nameList.stream()
	.map(name -> "'" + name + "'" )
	.collect(Collectors.joining(","));

System.out.println(sql1);
```



**split**

*형식 : split( String regex, int limit ) : limit은 토큰 갯수를 설정. -1을 넣을 경우 마지막

*StringTokenizer와의 차이

1. StringTokenizer는 클래스, split은 String 클래스의 메소드
2. split은  StringTokenizer와 다르게 인자로 정규식을 사용. 그래서 StringTokenizer가 속도는 좋다. 그러나 가변적인 요소가 많거나 정확한 것을 원하면 split이 더 좋음.

*StringTokenizer 주요 메소드

| 반환값  |    메소드 명    |        설명         |
| :-----: | :-------------: | :-----------------: |
| boolean | hasMoreTokens() | 남아 있는 토큰 여부 |
| String  |   nextToken()   |    토큰 꺼내오기    |

```java
/* 예시 */
public class StringDivideTest {
    public static void stringTokenizerTest(String str) {
        System.out.println("====== stringTokenizerTest() result ======");
        StringTokenizer tokenizer = new StringTokenizer(str, ",");
        for (int i = 0; tokenizer.hasMoreTokens(); i++) {
            System.out.println(i + "번째 : " + tokenizer.nextToken());
        }
    }
 
    public static void splitTest(String str) {
        System.out.println("====== splitTest() result ======");
        String split[] = str.split(",");
        for (int i = 0; i < split.lenght; i++) {
            System.out.println(i + "번째 : " + split[i]);
        }
    }
}
```

*위의 메소드를 기준으로 아래와 같이 문자열에 따라 결과 값이 달라진다.

```java
/* 예시 1 : 데이터 + 구분자 + 데이터 */
public static void main(String[] args) {
    String str = "apple,banana,kiwi";
    stringTokenizerTest(str);
    splitTest(str);
}
/* 결과 값 
====== stringTokenizerTest() result ======
0번째 : apple
1번째 : banana
2번째 : kiwi
====== splitTest() result ======
0번째 : apple
1번째 : banana
2번째 : kiwi
*/

/* 예시 2 : 데이터 + 구분자 + 구분자 + 데이터 */
public static void main(String[] args) {
    String str = "apple,banana,,kiwi";
    stringTokenizerTest(str);
    splitTest(str);
}
/* 결과 값 
====== stringTokenizerTest() result ======
0번째 : apple
1번째 : banana
2번째 : kiwi
====== splitTest() result ======
0번째 : apple
1번째 : banana
2번째 : 
3번째 : kiwi
*/

/* 예시 3 : 데이터 + 구분자 */
public static void main(String[] args) {
    String str = "apple,banana,kiwi,";
    stringTokenizerTest(str);
    splitTest(str);
}
/* 결과 값 
====== stringTokenizerTest() result ======
0번째 : apple
1번째 : banana
2번째 : kiwi
====== splitTest() result ======
0번째 : apple
1번째 : banana
2번째 : kiwi
*/

/* 예시 4 : 데이터 + 구분자 (구분자 뒤에 마지막도 표현하고 싶을 경우) */
public static void main(String[] args) {
    String str = "apple,banana,kiwi,";
    stringTokenizerTest(str);
    splitTest(str); // String split[] = str.split(",", -1);로 변경
}
/* 결과 값 
====== stringTokenizerTest() result ======
0번째 : apple
1번째 : banana
2번째 : kiwi
====== splitTest() result ======
0번째 : apple
1번째 : banana
2번째 : kiwi
3번째 : 
*/
```

