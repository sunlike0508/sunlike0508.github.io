---
title:  "테스트주도개발 06"
excerpt: "Unitils 단위 테스트 지원 라이브러리"
classes: wide
categories:
  - TDD
tags:
  - [TDD]
last_modified_at: 2020-05-08
---



## 테스트 주도개발 6장

* 오픈 소스 중 하나인 Unitils(유닛틸즈)는 단위 테스트를 좀 더 쉽게 만들고 더 유연하게 유지할 수 있게 도와주는 일종의 단위 테스트 지원 라이브러리다.
* DBUnit과 같이 독립적이 아닌 다른 테스트 프레임워크와 같이 사용된다.



### 6.1 설치

* 다운 받고 경로 추가



### 6.2 Unitils의 단위 테스트 지원 기능들



#### 6.2.1 객체 동치성 비교

##### 동일성 vs 동치성

* 동일성은 같은 객체인가 판단하는 것

* 동치성은 객체가 표현하고자 하는 상태(속성 값)가 서로 일치하는가 따져보는 것

* 예시로 바로 보자

```java
public class Book {
    private String name;
    private String author;
    private int price;
    
    public Book(String name, String author, int price) {
        this.name = name;
        this.author = author;
        this.price = price;
    }
}
```

* 위 Book 객체를 비교하는 테스트 케이스

```java
@Test
public void testBook() throws Exception {
	Book aBook = new Book("사람은 무엇으로 사는가?","톨스토이", 9000);
    Book otherBook = new Book("사람은 무엇으로 사는가?","톨스토이", 9000);
	assertEquals(aBook, otherBook);
}
```

* 위의 테스트를 실행하면  다음과 같이 오류가 발생한다.

```java
Java.lang.AssertionError: expected:<main.Book@16f0472> but was:<main.Book@18d107f>
at org.junit.Assert.fail(Assert.Java:91)
```

* 이는 의도하는 객체의 상태는 같으나 결과는 같은 객체가 다르다고 판정.
* 따라서 원하는 객체의 상태를 비교하기 위해 필드 값을 비교해야한다.

* 하지만 필드가 많아지만 아래와 같이 다 비교하기에는 불편하다















































* IDatabaseTester를 이용하면 DBTestCase를 상속받지 않아도 됨. IDatabaseTester에 이미 DBTestCase가 상속되어 있음.
* 1- IDatabaseTester에는 DB 연결과 데이터셋 관련 기능이 정의
* 2- DbUnit에서 제공하는 4개의 구현체

| 구현체                            | 설명                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| JdbcDatabaseTester                | DriverManager를 이용해 DB 커넥션을 생성                      |
| PropertiesBasedJdbcDatabaseTester | DriverManager를 이용해 DB 커넥션을 생성. 단, 연결 설정은 시스템 프로퍼티로부터 읽어들인다 |
| DataSourceDatabaseTester          | javax.sql.DataSource를 이용해 DB 커넥션을 생성               |
| JndiDatabaseTester                | JNDI를 이용해 DataSource를 가져온다.                         |

* 3- 데이터셋 지정
* 4- DB 커넥션과 데이터셋을 이용해 DB에 특정 작업을 수행. 
* DatabaseOperation 에 여러 종류가 있음
* 그 중에 CLEAN_INSERT는 데이터셋에 지정된 DB 테이블의 내용을 모두 지운 다음 데이터셋에 들어 있는 값으로 채워 넣는다.
* 의미적으로 DatabaseOperation 의 DELETE_ALL과 INSERT 두 동작을 연속으로 수행한 것과 동일

##### 전체 해석

* 위의 setUp 메소드는 테스트 메소드가 수행되기 전에 항상 seller.xml에 지정된 상태로 테이블 초기화





#### 5.2.2 테이터셋 비교

```java
@Test
public void testBook() throws Exception {
    Book aBook = new Book("사람은 무엇으로 사는가?","톨스토이", 9000);
    Book otherBook = new Book("사람은 무엇으로 사는가?","톨스토이", 9000);
    assertEquals(aBook.getName(), otherBook.getName());
    assertEquals(aBook.getAuthor(), otherBook.getAuthor());
    assertEquals(aBook.getPrice(), otherBook.getPrice());
}
```

* 그래서 Unitils는 이런 불편함을 감소하기 위해 리플렉션 단정문이라는 기능을 제공



#### 6.2.2 리플렉션 단정문(Reflection Assertion)

> #### assertReflectionEquals(예상 객체, 실제 객체); 
>
> #### assertReflectionEquals([메시지], 예상 객체, 실제 객체);

* 형식은 assertEquals와 같다.
* 아래는 예시

```java
import static org.unitils.reflectionassert.ReflectionAssert.*;

public class BookTest {
    @Test
        public void testBook() throws Exception {
        Book aBook = new Book("사람은 무엇으로 사는가?","톨스토이", 9000);
        Book otherBook = new Book("사람은 무엇으로 사는가?","톨스토이", 9000);
        assertReflectionEquals("Book 객체 필드 비교", aBook, otherBook);
    }
}
```

* 단정문에서 몇 가지 옵션을 지정할 수 있다.
* 대부분 소스코드가 리펙토링이 일어나면서 발생하는 테스트 케이스의 깨짐을 보완하기 위해 사용.
* 이 방식을 너그러운 단정문 적용이라고 부른다.



#### 6.2.3 리플렉션 단정문의 너그러운 비교(Lenient Assertion)

> #### assertReflectionEquals(예상 객체, 실제 객체, ReflectionComparatorMode);

##### ReflectionComparatorMode 옵션

| ReflectionComparatorMode | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| LENIENT_ORDER            | 컬렉션이나 배열 비교시 순서 무시                             |
| IGNORE_DEFAULTS          | 예상 객체 필드 중 타입 기본값을 갖는 필드에 대해서 비교하지 않음 |
| LENIENT_DATES            | 시간, 날짜 타입은 비교 안함                                  |



##### 6.2.3.1 LENIENT_ORDER

* 예시를 보자

```java
List<Integer> myList = Arrays.asList(3, 2, 1);
assertReflectionEquals(Arrays.asList(1, 2, 3), myList, LENIENT_ORDER);
```



##### 6.2.3.2 IGNORE_DEFAULTS

* Java에서 int의 0, 객체의 null, boolean의 false은 각 타입의 기본 값이다.
* IGNORE_DEFAULTS은 필드 값에 같은 타입 기본값이 할당 되어 있으면 동치성 비교에 포함시키지 않는다.
* 이때 기준은 expected 객체를 기준으로 한다. 

* 예시를 보자

```java
Item expectedItem = new Item("IKH-001", null, 24000);
Item actualItem = new Item("IKH-001", "20040601", 24000);
assertReflectionEquals(expectedItem, actualItem, IGNORE_DEFAULTS);
// null이 만약 actualItem에 있었다면 오류가 발생
```



##### 6.2.3.3 LENIENT_DATES

* 예시를 보자.

```java
Item expectedItem = new Item("IKH-001", null, 24,new Date(System.currentTimeMillis()+1));
Item actualItem = new Item("IKH-001", null, 24000, new Date(System.currentTimeMillis()));
assertReflectionEquals(expectedItem, actualItem, LENIENT_DATES);
```

* Unitiles에는 assertLenientEquals를 제공한다.
* ReflectionComparatorMode의 assertReflectionEquals 간략화 버전
* 아래는 위의 세 개의 옵션 중 LENIENT_DATES를 제외한 두 개를 동시에 적용해서 비교

```java
List<Integer> bag = Arrays.asList(100, 200, 300);
assertLenientEquals(Arrays.asList(300, 200, 100), bag);
// 배열의 순서가 다른 경우
assertLenientEquals(new String[]{"a", "B", "c"}, new String[]{"B","c","a"});
// 필드값이 타입 기본값일 경우 비교에서 제외
Item expectedItem = new Item("IKH-001", null, 24000);
Item actualItem = new Item("IKH-001", "20040601", 24000);
assertLenientEquals(expectedItem, actualItem);
//위 모두 성공
```



#### 6.2.4 프로퍼티 단정문(Property Assertions)

* 객체의 필드를 비교하려면 getter 메소드로 직접 확인하면 된다.
* 그러나 getter가 없다면? 임시로 getter를 만들어도 되나 assertPropertyLenientEquals를 사용하자.

> #### assertPropertyLenientEquals(속성 이름, 예상되는 속성 값, 실제 객체)

```java
@Test
public void testPlayerPropertyTest() throws Exception {
    Player player = VolleyballTeamRepository.getCaptain();
    assertPropertyLenientEquals("age", 31, player);
    assertPropertyLenientEquals("experienceYear", 15, player);
}
//age, experienceYear의 getter가 없다고 가정. 이를 위해 assertPropertyLenientEquals 사용
```

* 이것의 장점은 자바 빈 규칙을 따른다.
* 예를 들어 getter 메소드가 생기면 bean 규약에 맞는 getter 메소드를 이용해 프로퍼티 값을 불러와서 비교



### 6.3 Unitils 모듈

![]({{site.url}}/assets/images/tdd6.PNG)



```wiki
* MS 엑셀 문서를 데이터셋으로 인식한다.
* 엑셀 문서 내의 각 시트(sheet)를 테이블로 인식한다.
* 시트의 첫 번째 줄을 컬럼 이름으로 인식한다.
* 나머지 줄은 데이터 값으로 인식한다.
```



#### 5.3.5 ReplacementDataSet

```wiki
* 테이터셋에서 특정한 문자열을 치환하기 위해 사용한다.
* 보통은 null 값을 다르게 표현하고 런타임 시에 치환하는 데 많이 사용한다.

<dataset>
	<EMPLOYEE NO="101" NAME="안병현" EMAIL="megane@hssm.kr"/>
	<EMPLOYEE NO="102" NAME="김상옥" EMAIL="[null]"/>
</dataset>

* 위와 같은 데이터셋 파일을 만들고 아래와 같이 코드로 읽어드려서 null 값을 변환
ReplacementDataSet dataSet = new ReplacementDataSet( new FlatXmlDataSet(……));
dataSet.addReplacementObject("[NULL]", null);
```



### 5.4 DbUnit의 DB 지원 기능

* 위에서 사용한 DatabaseOperation 클래스의 setUp 메소드 중 일부

```java
public void setUp() throws Exception{
	DatabaseOperation.CLEAN_INSERT.execute(databaseTester.getConnection(), dataSet);
}
```

> #### 형식 : DatabaseOperation.오퍼레이션이름.execute( DB커넥션, 데이터셋 );



| 오퍼레이션 의 종류      | 설명                                                         |
| ----------------------- | ------------------------------------------------------------ |
| INSERT                  | * 데이터베이스에 데이터셋 내용을 INSERT <br>* PK(primary key)를 기 준으로 대상 테이블에 중복 데이터가 들어 있지 않다는 가정하에서 동 작하기 때문에 중복 데이터가 존재하면 실패로 간주<br>* FK(foreign key, 참조키)가 걸려 있는 테이블의 경우 데이터셋의 순서에 따라 정상 적으로 INSERT가 안 될 수 있으므로 유의한다 |
| DELETE_ALL              | * 데이터셋에 지정된 테이블들의 데이터를 모두 지운다. 지정되지 않은 테이블들은 건드리지 않는다. |
| CLEAN_INSERT            | * 데이터셋에 지정된 테이블에 대해 DELETE_ALL을 수행한 다음, 데이 터셋에 있는 데이터 값을 INSERT<br>* REFRESH와 함께 매우 잘 사용되는 기능이다. |
| UPDATE                  | * 데이터셋의 내용으로 테이블을 업데이트                      |
| REFRESH                 | * CLEAN_INSERT와 함께 가장 많이 사용되는 기능 <br>* 대상 테이블에 존 재하지 않는 데이터는 INSERT, 이미 존재하는 데이터일 경우에는 UPDATE한다. <br>* 둘 다에 속하지 않는, 이미 테이블에 존재하는 데이터는 건드리지 않는다. |
| DELETE                  | * 데이터셋과 일치하는 데이터를 테이블에서 지운다. 테이블 전체를 지 우지는 않는다. |
| TRUNCATE                | * 데이터셋에 지정된 테이블들의 데이터를 모두 지운다. <br>* TRUNCATE는 DELETE와 달리 롤백(rollback)이 불가능하다. <br>* 테이블 데이터 삭제 작 업은 데이터셋에 지정된 테이블 순서의 역순으로 적용된다. |
| CompositeOperation      | * 여러 개의 DatabaseOperation을 하나로 묶어서 한 번에 실행한다. <br>* 이런 방식을 DatabaseOperation 클래스를 데코레이트 한다고 표현한다. DatabaseOperation op = new CompositeOperation( 　　　　　　　DatabaseOperation.DELETE_ALL, DatabaseOperation.INSERT); op.execute(connection, xmlDataSet); <br>* 위 코드는 DELETE_ALL과 INSERT를 하나의 DatabaseOperation으로 묶은 모습이다. |
| TransactionOperation    | * 데이터셋을 처리할 때 트랜잭션으로 묶어서 처리할 것인지를 결정한 다. <br>* DatabaseOperation 클래스를 데코레이트한다. <br>DatabaseOperation op = new CompositeOperation( 　　　　　　　DatabaseOperation.DELETE_ALL, 　　　　　　　DatabaseOperation.INSERT); op = new TransactionOperation(operation); op.execute(connection, xmlDataSet); <br>* 중간에 실패하면 전부 롤백 |
| IdentityInsertOperation | * MS SQL 서버의 IDENTITY 컬럼을 잠시 비활성화시킨 상태로 만들어 INSERT 시에 오류가 발생하지 않도록 도와준다. <br>* IDENTITY 컬럼은 자동으로 숫자가 증가해서 입력되는 컬럼으로, 특정 값을 강제로 넣는 것이 일반적인 INSERT 문으로는 불가능하다. |

##### 데코레이트란?

* 대상이 되는 객체를 감싸서 객체의 기능을 확장하는 기법
* 뭔소리지? 이해불가.





#### 5.5장은 Ant로 예를 드는데 요즘은 안쓰므로 gradle로 쓰는 것을 찾아보자

* 따로 이는 포스팅하자



### 5.6 정리

* DbUnit을 사용하는 것은 어렵지 않다.
* 단지 만드는 비용과 노력이 많이 든다. 
* 따라서 DB를 사용할 때 반드시 사용할지 고민할 필요가 있다.
* 단순히 SQL 파일을 테스트 전후로 실행하는 편이 더 나을 수도 있다.



#### 5.6.1 권장 사용법

* 개발자마다 데이터베이스 인스턴스나 스키마를 하나씩 쓸 수 있게 하라.
* 나중에 정리(tearDown)할 필요가 없도록 setUp 처리를 잘 하자.
* 데이터셋 크기는 작게하고 여러개 만들어라. 꼭 필요한 테스트 데이터 위주로 만들자
* 데이터셋을 너무 만들지 마라. 유지보수가 힘들다
* 데이터셋은 테스트 클래스 기반으로 만들고 여러 테스트 클래스와 공유해서 사용하지 말자
* 테스트용 데이터베이스에서는 참조키나 널값 제약 기능을 꺼놓으면 편리하다.