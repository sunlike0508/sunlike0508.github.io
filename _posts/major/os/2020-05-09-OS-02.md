---
title:  "운영체제 - 02"
excerpt: "컴퓨터시스템의 구조"
classes: wide
categories:
  - 운영체제
tags:
  - [운영체제]
last_modified_at: 2020-05-12
---



# 운영체제 - 컴퓨터시스템의 구조

![]({{site.url}}/assets/images/os12.PNG)



### 1. 컴퓨터 시스템의 구조

#### 1.1. Mode bit

* 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치 필요

* 하드웨어적으로 두 가지 모드의 operation 지원

  > 1 사용자 모드 : 사용자 프로그램 수행
  >
  > 0 모니터 모드 : OS 코드 수행 (ex: 커널모드, 시스템 모드)

* 보안에 위협이 되는 명령어는 모니터 모드에서만 수행가능 한 **특권 명령** 으로 규정
* 인터럽트나 예외 발생 시 하드웨어가 모드 비트를 0으로 바꿈.
* 사용자 프로그램에게 CPU를 넘기기 전에 1로 바꿈

#### 1.2. Registers PC

* 다음에 실행할 프로그램이 있는 메모리의 주소를 가지고 있는 저장 공간

#### 1.3. Timer

* 일정 시간마다 인터럽트를 발생 시킴
* CPU를 특정 프로그램이 독점하는 것으로부터 보호
* Time sharing을 구현하기 위해 이용
* 현재 시간을 계산하기 위해서도 이용

#### 1.4. 인터럽트

* Trap(소프트웨어 인터럽트) : ex) 시스템 콜, exception
* Interrupt(하드웨어 인터럽트) : ex) 타이머, 입력장치

##### 1.4.1인터럽트 백터

* 인터럽트 발생 시 처리해아할 코드가 어디 있는지 주소를 가지고 있는 것

##### 1.4.2인터럽트 처리 루틴

* 인터럽트 백터가 있는 해당 코드를 말함

#### 1.5. Device Controller

* CPU는 하드웨어. 그러니까 이것도 하드웨어
* 여기 안에도 소프트웨어가 있음. (Device driver). 
* CPU에 입력을 요청 & CPU의 출력 요청을 처리 (I/O에 전반적인 처리를 관리)

#### 1.6. 시스템콜

* 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는것
* 그러니까 CPU가 I/O에 직접 접근을 못함
* 그런데 어떤 사용자 프로그램이 CPU를 사용 도중 DISK에 있는 파일 시스템을 읽어들이고 싶어함
* 이를 특권명령(사용자 프로그램은 DISK에 직접 접근이 불가능)이라고 함.
* 그래서 운영체제(모든 권한을 가지고 있음)한테 부탁해야 함.
* 그래서 사용자 프로그램이 직접 인터럽트를 걸어서 운영체제에게 CPU 사용권을 넘김
* 이것을 시스템 콜이라고 한다.



### 2. 동기식 입출력과 비동기식 입출력

* 사실 동기식, 비동기식이라는 한국말이 없음. 억지로 번역한 것
* 영어는 Synchronous, asynchronous라는 단어가 있음. 그래서 그 느낌을 알아함.
* 예를 들어서 싱크로나이즈 수영?, 립싱크 같은 걸 떠올리면 됨.
* I/O 동기화, 프로세스의 동기화 이럴 경우 조금 다르지만 큰 의미는 같음

![]({{site.url}}/assets/images/os13.PNG)

* 예를 들어 시스템콜이 생겼다고 가정하자
* A란 프로그램은 시스템 콜을 이후 CPU는 파일을 읽는 동안 가만히 대기를 한다. 파일이 넘어오면 다시 수행 이를 동기식
* 반대로 시스템콜 이후 파일 읽는 동안 CPU는 다른 프로그램을 가지고 일을 한다. 비동기식
* 쉽게 말하면 I/O 작업이 끝날때까지 기다리냐? 안기다리냐? 기다리면 동기식, 기다리지 않으면 비동기식



### 3. DMA(Direct Memory Access)

* 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용
* device 컨트롤러가 CPU와 인터럽트를 통해 매번 메인 메모리에 디바이스에 읽은 내용을 올림
* 근데 이게 너무 비효율적. 그래서 직접 CPU에 올리기 위해서 사용



## 프로그램의 전체적인 실행

### 1. 프로그램의 실행(메모리 load)

![](C:/Users/user/Desktop/myBlog/sunlike0508.github.io/_posts/major/os/{{site.url}}/assets/images/os14.PNG)

* 파일 시스템에 있는 프로그램들이 실제 실행하기 위해서 물리적 메모리에 올라가야 하는데

* 파일 시스템에 존재하는 프로그램의 가상 메모리의 주소와 실제 실행되는 물리적 메모리 주소는 다르다.
* 이를 변환 시키기 위해 address translation이 필요하다.

* 가상 메모리에 있는 프로세스들의 stack은 해당 프로세스가 실행할될 때 필요한 함수들을 호출하면 함수들의 주소를 쌓는 공간을 말한다. 또한 지역변수도 여기에 쌓임

* data는 말 그대로 data 영역. 전역변수 영역

* code는 함수들이 컴파일되어 기계어로 바뀌어 위치되는 영역
* 운영체제의 물리적 메모리도 똑같이 stack, data, code 영역으로 구성되어 있음



### 2. 커널 주소 공간의 내용

![](C:/Users/user/Desktop/myBlog/sunlike0508.github.io/_posts/major/os/{{site.url}}/assets/images/os15.PNG)

* 운영체제는 I/O와 프로세스들에 대한 자원 관리를 해야하므로 각각에 대하여 메모리와 자료구조를 가지고 있음
* 커널의 stack은 프로세스가 실행되다가 운영체제한테 어떤 일에 대하여 요청. 그럼 운영체제는 stack에 이전 실행되었던 프로세스를 담아두고 운영체제가 CPU 사용하다가 stack을 보고 필요한 프로세스에 다시 권한을 넘겨줌.



### 3. 사용자 프로그램이 사용하는 함수

#### 3.1 사용자 정의 함수 (프로세스 Address의 Code 영역)

* 자신의 프로그램에서 정의한 함수

#### 3.2 라이브러리 함수 (프로세스 Address의 Code 영역)

* 자신의 프로그램에서 정의하지 않고 갖다 쓴 함수
* 자신의 프로그램의 실행 파일에 포함되어 있다.

#### 3.3 커널 함수 (커널 Address의 Code 영역)

* 운영체제 프로그램의 함수
* 커널 함수의 호출 = 시스템 콜

##### 즉, 커널 함수는 CPU의 제어권을 넘겨야하고 위의 두개는 자신의 함수를 사용한다.

* 예시

![](C:/Users/user/Desktop/myBlog/sunlike0508.github.io/_posts/major/os/{{site.url}}/assets/images/os16.PNG)





















