---
title:  "운영체제 - 01"
excerpt: "운영체제 개요"
classes: wide
categories:
  - 운영체제
tags:
  - [운영체제]
last_modified_at: 2020-05-09
---





## 강의

http://www.kocw.net/home/search/kemView.do?kemId=1226304



# 운영체제 - 개요 1

* 컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층

* 컴퓨터 시스템의 자원을 효율적으로 관리
* 자원이란 CPU, 메모리, I/O 장치등을 말한다.
* 주어진 자원으로 최대한의 성능을 내도록 하는 효율성을 냄
* 특정 사용자/프로그램의 지나친 불이익이 발생하지 않도록 하는 형평성을 관리
* 사용자 및 운영체제 자신을 보호



### 1. 운영체제의 기능

![]({{site.url}}/assets/images/os1.PNG)

* 운영체제의 핵심인 커널이 메모리에 상주
* 나머지 프로그램들이 메모리를 차지하며 실행
* CPU가 매 순간(클럭) 메모리에 위치한 명령어(기계어)를 읽어들여 수행
* I/O 장치들은 바로 명령을 보내는게 아니라 각자 자기가 가지고 있는 I/O controller(or 메모리)에서 메인 메모리에 명령을 요청. 반대로 I/O 장치에게 요청을 할때도 중간 control하는 장치가 있음.
* CPU는 어떤 프로그램에게 사용권을 줄까?(==누구 명령을 먼저 처리해줄까?) 판단.  
* 무한정 사용권을 막기위해 CPU 스캐쥴링이 필요
* 한정된 메모리를 어떻게 쪼개어 쓸지 고민하기 위해 메모리 관리가 필요
* 디스크에 들어온 요청을 어떤 순서(프로그램 A, B, C가 동시에 요청할 경우) 로 처리할지 고민하기 위해 디스크 스케쥴링이 필요. 쉬운 예시로 엘리베이터. 
* CPU의 속도는 I/O 장치 보다 100만배이상 차이. 이를 극복하기 위해 인터럽트, 캐싱
* 캐싱은 반복되는 작업을 피하기 위해 같은 요청을 바로 처리 하기 위한 기법
* I/O장치가 요청받은 작업을 끝마쳤다고 CPU에게 알려주는 신호가 인터럽트



### 2. 프로세스의 상태

![]({{site.url}}/assets/images/os2.PNG)

* CPU는  한 개 이기 때문에 여러 I/O 장치에서 보내는 요청을 큐에 대기



### 3. CPU 스케쥴링

#### 3.1 FCFS (First Come First Served)

![]({{site.url}}/assets/images/os3.PNG)

* 선착순 알고리즘
* P1은 기다리는 시간 0, P2는 기다리는 시간 24초, P3 기다리는 시간 27초
* 평균 대기 시간 17



![]({{site.url}}/assets/images/os4.PNG)

* P2가 먼저 들어왔다고 가정하면 위의 그림처럼 평균 대기 시간이 줄어듬



#### 3.2 SJF (Shortest-Job-First)

![]({{site.url}}/assets/images/os5.PNG)

* 금번 CPU 사용시간이 가장 짧은 프로세스를 제일 먼저 스케쥴
* 최소 평균 대기 시간을 보장
* 문제는 형평성
* 오래 걸리는 요청(프로그램 or 명령)은 결과를 못 받을 수 있음.



#### 3.3 RR (Round Robin)

![]({{site.url}}/assets/images/os6.PNG)

* SJF의 문제(형평성)를 해결하기 위한 스케쥴링

* 할당시간 만큼만 씀
* 다 쓰면 출력
* 다 못쓰면 대기큐로 돌아감
* 어떤 프로세스도 (N-1) X 할당시간 이상 기다리지 않음
  * N은 프로세스 총 개수
  * -1을 하는 이유는 자기 자신 제외



### 4. 메모리 관리

![]({{site.url}}/assets/images/os7.PNG)

* 디스크(파일시스템)은 실행파일들이 저장되어 있는 공간. 비휘발성. 

* 디스크(파일시스템)에서 실행파일을 실행시키기 위해가상메모리에서 프로세스가 실행되어 메모리에 올린다.
* 이때 메모리가 가득 차면 메모리에 있던 기존의 가상메모리의 실행파일 프로세스가 나가야 한다.
* 나간 가상메모리의 실행파일 프로세스를 보관해야하는 그 영역을 디스크(스왑영역)이라고 한다.
* 메모리는 휘발성. 컴퓨터가 꺼지면 날라감
* 디스크(스왑영역) 또한 휘발성
* 가상 메모리 또한 휘발성



![]({{site.url}}/assets/images/os8.PNG)

* 그렇다면 메모리가 가득 찼을 때 어떤 메모리를 나가라고 할껀가?
* 앞으로(미래)의 어떤 페이지가 요청 들어올지 예측해야한다. (미래는 알 수 없기 때문에)
* 문제는 어떻게 어떤 페이지가 요청 올지 예측할 수 있나?

#### 4.1 LRU (가장 오래전에 참조 페이지 삭제)

* 페이지 1을 삭제
* 오래되었지만 참조가 가장 많았다는건 앞으로 많이 참조될 수 있다는 가능성을 무시

#### 4.2 LFU (참조 횟수가 가장 적은 페이지 삭제)

* 페이지 4를 삭제
* 여기서 문제가 발생. 참조 횟수가 적은 페이지가 최근 들어왔는데 앞으로 참조가 많아질 수 있음.



### 5. 디스크 스케쥴링

* 하드디스크(HDD)안에 디스크가 있음. 그 디스크를 말함
* 디스크의 접근 시간중에 가장 많이 차지하는건 디스크 헤드 이동.
* 디스크 대기 큐의 순서를 바꾸더라도 헤드 이동을 줄이는 방법이 최고
* 헤더 이동을 검색하는 것을 탐색 시간(Seek Time)이라고 함
* 이 탐색시간을 줄이는 것. 이를 디스크 스케쥴링이라고 함

#### 5.1 FCFS (First-Come First-Served)

* CPU 스캐쥴링의 FCFS랑 같음
* 효율성 문제

#### 5.2 SSTF (Shortest Seek Time First)

![]({{site.url}}/assets/images/os9.PNG)

* FCFS의 효율성 문제는 해결

* CPU 스케쥴링의 SJF랑 똑같은 문제 형평성(starvation: 기아) 문제 발생



#### 5.3 SCAN

![]({{site.url}}/assets/images/os10.PNG)

* 헤드가 디스크의 한쪽 끝에서 다른쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리
* 다른 한쪽 끝에 도달하면 역방향으로 이동하며 오는 길목에 있는 모든 요청을 처리하며 다시 반대쪽으로 이동





### 6. 저장장치 계층구조와 캐싱

![]({{site.url}}/assets/images/os11.PNG)

* CPU 와 메모리들 간의 구조
* CPU안에 레지스터(기계어를 전달), 캐쉬메모리, 메인메모리(D램)이 있음
* 캐쉬는 레지스터와 메인메모리 사이에서 속도를 완충하기 위한 보조 메모리
* 그림에서 올라갈수록 빠름. 내려갈수록 느림
* 그림에서 올라갈수록 비쌈. 내려갈수록 쌈
* 그림에서 올라갈수록 용량이 작음. 내려갈수록 큼
* Primary는 휘발성, Secondary는 비휘발성
* 그림에서 CPU가 Primary에 직접 접근 가능. Secondary는 불가능
* 따라서 Secondary에 접근하기 위해서는 CPU 위에 올려놓고 접근해야함
* 실행하기 위해서는 primary로 올려야하고, 저장하기 위해서는 Secondary로 내려야함.
* 문제는 올라갈수록 메모리가 한도가 있으므로 많은 요청을 처리하기 위해 이전에 어떤 요청들을 처내야하는가?



### 플래시 메모리

* NAND형(스토리지), NOR형(임베디드 코드저장용)
* 요즘은 다 NANA형
* 특징 (하드디스크에 비해)
  1. 저전력
  2. 충격에 강함
  3. 작은 사이즈
  4. 가벼움
  5. 전원이 나가도 메모리에 남음
* 모바일 저장장치로 시작
* 요즘은 데이터센터에서 사용하기 위해 확장되어 가는중
* 단점은 쓰기 횟수가 제약. (즉 많이 쓰면 망가짐)
* 또한 시간이 지나면 데이터가 변질됨(전하를 통해 0,1을 읽어드리는데 시간이 지나면 전하의 양이 빠져나가기 때문에)
* 이를 위해 소프트웨어를 통해서 보완해야함



# 운영체제의 개요 - 2



### 1. 운영체제란 무엇인가?

* 운영체제의 핵심인 커널이 메모리에 상주하는 부분 (좁은 의미)
* 커널 뿐 아니라 각종 주변 시스템 유틸리티를 포함한 개념(넓은 의미)



### 2. 운영체제의 목적

* 컴퓨터 시스템의 자원을 효율적으로 관리
* 자원은 HW, SW 모두 포함한 의미
* 무조건 효율이 아닌 형평성도 고려



### 3. 운영체제의 분류

#### 3.1 동시 작업 가능 여부

##### 3.1.1 단일 작업

* 한 번에 하나의 작업만 처리

##### 3.1.2 다중 작업

* 동시에 두 개 이상의 작업 처리
* 요즘은 모두 다중 작업



#### 3.2 사용자 수

##### 3.2.1 단일 사용자

* ex) MS Windows

##### 3.2.2 다중 사용자

* ex) UNIX



#### 3.3 처리방식

##### 3.3.1 일괄 처리

* 작업 요청의 일정량 모아서 한꺼번에 처리
* 작업이 완전 종료될 때까지 기다려야 함
* 요즘은 거의 안쓰임

##### 3.3.2 시분할(Time sharing)

* 여러 작업을 수행할 때 컴퓨터 처리 능력을 일정한 시간 단위로 분할하여 사용
* 일괄 처리 시스템에 비해 짧은 응답 시간을 가짐
* interactive한 방식
* 우리가 보통 쓰는 컴퓨터의 방식 (범용 컴퓨터)

##### 3.3.3 실시간

* 정해진 시간 안에 어떠한 일이 반드시 종료됨이 보장되어야 하는 실시간 시스템
* ex) 원자로/ 공장제어, 미사일 제어 등



##### 멀티프로세서 : 하나의 컴퓨터에 CPU가 여러 개 붙어 있음을 의미. 우리가 보통 쓰는 건 멀티프로세서이지만 강의에서 가르치는 건 초기의 1개의 CPU가 있다는 가정으로 배움



### 4. 운영 체제의 예

#### 4.1 유닉스

* C언어로 작성
* 높은 이식성
* 최소한의 커널 구조
* 복잡한 시스템에 맞게 확장 용이
* 소스 코드 공개
* 프로그램 개발에 용이
* 다양한 버전 : Solaris, Linux 등
* 대용량 서버, 다수의 동시 사용을 위해 만듬

#### 4.2 DOS

* MS 사에서 1981년에 일괄, 단일 사용자를 위해 만듬
* 이제는 안씀...

#### 4.3 MS Windows

#### 4.4. Handeld device를 위한 OS

* Android, IOS



























