---
title:  "전송계층"
excerpt: "전송계층"
classes: wide
categories:
  - 네트워크
tags:
  - [네트워크]
last_modified_at: 2020-06-18
---



## 강의

http://www.kocw.net/home/search/kemView.do?kemId=1159726



# 전송계층

* Relaiable Networking (End to End)

![]({{site.url}}/assets/images/net04.PNG)

* 네트워크의 이상적인 모습은 A에서 B로 direct하게 bit stream 형태로 가는 것이다.
* 그러나 현실은 그렇지 않다.
* 무한한 흐름 X, 패킷 유실, 패킷 순서 바뀜, 패킷 변조가 생긴다.
* 이를 위해 보낼 데이터를 패킷으로 나누어 서버로 부터 응답을 받아 패킷을 유실되지 않게 문제를 해결하기 위한 해결책이 있다.
* 그러나 이것은 네트워크의 성능 문제(지연시간, 전송률)가 있다.
* 성능을 해결해보자.



### 1. Pipelining

* 연속된 대량의 작업이 순차성을 가지고 있으나 앞의 일이 종료하지 않고도 다음 일을 시작할 수 있는 병렬성을 가진 경우 성능 향상을 위해 사용하는 기법
* 이를 위해 두 가지 방법이 있다.



#### 1.1 Go-Back-N

* N개의 packet을 병렬적으로 처리

* 송신측에서는 N개의 packet을 버퍼링(재전송하기 위해서)

* 버퍼링이란 수신이 확실하지 않는 packet에 대하여 재전송 위하여 보관하는 공간. 즉 일단 송신하고 버퍼링에 넣는다. 버퍼링의 크기는 제한적이다.

* 수신측에서는 **순차적**으로 잘 수신된 packet에 대하여 ACK를 송신하고 packet의 payload(실제 전송하고자 하는 내용)를 응용계층으로 올려 보낸다.

* 송신측에서는 ACK를 받지 못하더라도 순차적 ACK가 온다면 수신측에서 순차적으로 해당 패킷까지 잘 받았다고 간주. 

  예를 들어 1,2,3,4 패킷을 순차적으로 보냈고 수신측에서도 순차적으로 잘 받고 ACK도 다 보냈다고 가정하자. 이때 3번 패킷에 대한 ACK가 중간에 유실. 그럼 송신측에서는 각 패킷에 대한 ACK가 1,2,4만 받는다. 그럼 송신측에서는 4를 받을 때 4번에 대한 정상 ACK가 왔다면 3번도 수신측에서 잘 받았을 꺼라고 간주.

* 송신측에서는 ACK가 온 패킷에 대해서 버퍼링에서 삭제 후 버퍼에 여유가 생기면 다음 패킷을 보내고 버퍼링에 넣는다.

* 수신측에서 순서에 맞지 않는 패킷이 온 경우 반응
  1. 조용히 있는다.
  2. 잘 받은 마지막 패킷에 대한 ack를 전송

##### 1.1.1 재전송 정책

* 각 패킷 전송시에 패킷을 위한 타임 설정
* ACK를 받으면 ACK 해당 패킷과 앞쪽 패킷 타임 소멸
* 타임 이벤트 발생하면 해당 패킷부터 재전송
* 추가 재전송 정책
  * N번째 패킷에 대한 ACK가 반복적으로 올 경우 N+1번째 패킷 유실을 의미
  * 예를 들어 1,2,3,4,5를 보내는대 수신측에서 2번 패킷을 못 받았다고 하자. 3번, 4번, 5번을 받고 나서 ACK를 보낼 때 3,4 ,5패킷에 대한 ACK가 아닌 1번 ACK를 연속해서 보내면 송신측에서 2번 패킷이 유실되었다고 생각하고 다시 2번부터 보낸다.

##### 1.1.2 장단점

* 단순(특히 수신측)
* 간결하게 시스템의 상태가 추상화
* 패킷 유실에 대한 복구 비용이 비싸다.



#### 1.2 Selective Repeat

* Go-Back-N의 단점을 보완
* 수신측에서도 버퍼링을 가짐
* 빠진 패킷이 있을 경우 그 뒤에 잘 도착한 패킷들을 버퍼에 보관
* 빠진 패킷이 추후 도착하면 버퍼에 저장한 이후 패킷들까지 순차적으로 응용계층에 전달

* 송신측에서는 보낸 패킷에 대한 ACK를 못 받고 타임 이벤트가 발생하면 다시 보낸다.
* 이때 수신측에서는 송신측에서 보낸 패킷이 수신측의 버퍼링에 있는 패킷이라면 잘 받았다고 ACK 보낸다.

##### 1.2.1 장단점

* 실패한 패킷에 대한 재전송이 좋아짐
* 시스템의 추상화가 복잡





















