---
title:  "트랜젝션"
excerpt: "트랜젝션"
classes: wide
categories:
  - 데이터베이스
tags:
  - [데이터베이스]
last_modified_at: 2020-07-22
---



## 강의

http://www.kocw.net/home/search/kemView.do?kemId=317898



# 트랜젝션

* 트랜잭션의 개념 및 특성
* 동시성(병행) 개념
* 동시성의 문제 및 제어 방법
* 회복 기법



### 1. 트랜잭션

* 분리되어서는 안 되는 기본 단위 작업(논리적 단위 작업)

* 예) 계좌 A에서 300원을 인출해서 계좌 B로 입금하라.

```
read(A) 	// 계좌 A의 금액
A = A - 300 // 300원 인출
write(A) 	// 계좌 A 갱신
read(B) 	// 계좌 B 금액
B = B + 300 // 300원 입금
write(B) 	// 계좌 갱신
```

* 여기서 A가 인출하는 순간, B에 입금하는 순간 문제가 생긴다면?



#### 1.1 트랜잭션이 성공하지 못하는 원인

* 시스템 고장 또는 사이트 고장
* 트랜잭션 고장
* 매체 또는 기기 고장
* 통신 고장
* 자연 재해
* 부주의 또는 고의적 오류



#### 1.2 트랜잭션의 특성

* ACID
* 원자성(Automicity)
  * 전부 실행 또는 전혀 실행하지 않음
  * 일부만 실행할 수 없음
* 일관성 (Consistency)
  * 실행 결과에 일관성이 있어야 함
  * 데이터베이스에 모순이 발생하지 않아야 함

* 고립성 (Isolatin)
  * 독립적으로 실행
  * 다른 트랜잭션에 간섭을 주거나 받지 말아야 함
* 지속성 (Durability)
  * 트랜잭션의 결과는 영속적임
  * 결과는 손실되지 않고 보존되어야 함



#### 1.3 트랜잭션의 상태

* 활성화 : 트랜잭션의 시작
* 부분완료 : 마지막 명령문 실행 직전
* 실패 : 비정상적으로 중단
* 철회 : 트랜잭션을 실패하여 롤백(rollback)
* 완료 : 트랜잭션을 성공적으로 수행
* 결과적으로 철회 아님 완료



#### 1.4 commit 과 rollback

* commit : 성공적인 종료, 완료
  * 데이터베이스의 내용이 갱신되고, 일관된 상태를 갖음.
* rollback : 비성공적인 종료, 철회
  * 트랜잭션에 이상이 발생, 실행이 취소되고, 최초 상태로 복귀
  * 중간결과는 취소되어야 함



### 2. 병행의 개념

* 병행 또는 동시성

* 인터러빙(interleaving)이라고도 함 : 일이 중첩이 되지 않음
* 이와 반대되는 개념이 오버래핑(overlapping) : 일이 중첩됨
* 예를 들어보자
* 요리사가 한명인 곳이 있다.
* 요리사는 라면, 갈비탕, 순두부를 동시에 만든다고 할 때, 동시에 3개를 만드는 것처럼 보인다.
* 그러나 딱 한 시점을 보면 라면을 끓이다가 같은 시점에 동시에 갈비탕, 순두부를 끓일 수는 없다.
* 라면을 물 올려놓는 시간 동안 갈비탕, 순두부 모두 물을 올릴 수는 없기 때문이다.
* 따라서 결과적으로 라면, 갈비탕, 순두부가 시간차이로 요리가 만들어진다.
* 컴퓨터는 너무 빨라서 동시(같은 시간)에 처리되는 것처럼 보이나 실제는 위의 예처럼 다른 시간에 처리됨.
* 우리나라가 번역을 거지 같이 했다. 동시= 병행 이렇게 봐야함 여기서는
* 반대로 요리가 여러명이 있다고 하자.
* A요리사가 라면을 끓이는 동안 B요리사는 갈비탕을 만든다.
* 이때는 어느 한시점을 봐도 라면, 갈비 모두 요리가 되고 있다.
* 이것은 요리가 중첩되어 만들어져 있으므로 시간의 흐름을 보았을 때 동시에 만들어지는 것으로 볼 수 있다.



#### 2.1 병행 프로세스

* 비동기적 병행 프로세스 (asycronized concurrency process)

* 즉, 아무때나 불규칙적으로 함께 수행되는 프로세스

* 요리사가 라면 물 올려놓고, 갈비탕 물 올리고, 순두부 물 올리고, 다시 라면 스프 넣고, 순두부 두부 넣고, 갈비탕 갈비 넣고, 순두부 고추가루 넣고 이렇게 불규칙하게 아무때나 함께 수행됨



#### 2.2 병행처리의 문제점

* 원인 : 공유데이터(자원) => 갱신 분실, 모순, 연쇄복귀

* 해결 방안: 상호 배제

* 충돌 : 같은 연산이 다른 트랜잭션에도 존재하고 동일한 데이터 항목에 접근하며 적어도 하나의 write 연산이 실행될 때, 충돌이 발생한다.

#### 2.3 해결

##### 2.3.1 직렬 스케쥴

* 순차 처리
* 처리 정확성
* 처리에 비효율성

##### 2.3.2 비직렬 스케줄

* 병행 처리
* 충돌 가능성
* 처리에 효율성



#### 2.4 총돌 동등과 충돌 직렬 가능 스케줄

![]({{site.url}}/assets/images/db62.PNG)

* 충돌 동등 : 충돌 연산을 포함하지만, 결과는 동일(정상)
* 충돌 직렬 가능 스케줄 : 충돌 연산을 포함하지만, 직렬화된 스케줄이 가능
* 그러나 이것은 현실적으로 구현하기 힘듬



#### 2.5 뷰 동등과 뷰 직렬 가능 스케줄

* 뷰동등

  1) 데이터 요소 x에 대하여 스케쥴 S에서 Ti가 x의 초기값을 읽는다면, 스케쥴 S`에서도 Ti가 초기값을 읽어야 한다.

  2)  스케쥴S에서 Ti가 수행한 모든 read(x)의 연간 값이 Ti가 수생한 write(x)가 생성한 값이라면, 

  S`에서 Ti가 수행한 모든 read(x)의 연산값도 Ti가 수행한 write(x)가 생선한 값이어야 한다.

  3) 스케쥴S 에서 Ti가 마지막 write(x)을 실행하였으면,  스캐쥴 S`에서도 Ti가 마지막으로 write(X)을 샐행하여야 한다.



### 3. 주요 동시성 제어 방법

* 직렬 스케쥴링

  * 충돌이 없도록 스케쥴을 직렬화
  * 그러나 이것은 만들기 어렵다. 비현실적
  * 그래서 아래 두 가지를 많이 사용한다.

* Locking

  * 주요 데이터 사용 시, lock and then execute
  * ex) phase locking

* Timestamp

  * 모든 트랜잭션에서는 시스템 전체를 통해 유일한 timestamp 사용
  * 교착상태(dead lock)가 절대 발생하지 않음

  

#### 3.1 로킹 기법

* 로킹
  * 트랜잭션의 병행기법
  * 상호배제 보장
  * 독점 제어 제공
* 구조
  * lock : lock 걸려있으면 대기 아니면 계속
  * 공유데이터 read, write
  * unlock : lock 해제

* 로킹 규약의 제약
  * 하나의 트랜잭션이 공유데이터(임계 구역)를 사용할 수 있다.
  * 판독을 목적으로 하는 경우에는, 동시 접근해도 문제가 없다.

##### 3.1.1 2단계 로킹 규약

* 확장 단계
  * 새로운 lock 연산만을 실행할 수 있고 unlock 연산을 수행할 수 없는 단계
* 축소 단계
  * unlock 연산을 실행할 수 있고, unlock 연산이 실행되면 lock 연산을 실행할 수 없는 단계
* 2단계 로킹 규약(2PLP)
  * 어느 스케쥴에 참여하고 있는 모든 트랜잭션이 2단계 로킹 규약을 준수하였다면 이 스케쥴은 직렬 가능하다.
  * 한 트랜잭션에서 모든 lock연산들이 첫 번째 unlock 연산 이전에 실행되었다면, 이 트랜잭션을 2PLP를 준수하였다고 할 수 있다.

![]({{site.url}}/assets/images/db63.PNG)

* 위의 예제를 보자
* T1, T2 스케쥴이 있다. 이것은 병행으로 T1, T2이 실행되고 있다.
* T1이 먼저 x를 lock하고 unlock을 했다. 그리고 y를 lock했다.
* T2가 그 다음 실행되는 x를 lock했다. T1에서 x를 unlock했기 때문에 가능하다. 그리고 x에 대해서 연산을 수행한다.
* 이와 병행으로 T1은 y를 수행하다가 y를 unlock했다.
* T2는 x연산을 하면서 y를 lock한다. 그리고 x 연산이 끝나서 unlock하고 y에 대해서 마무리 연산 후 unlock 한다.
* 이것은 병행으로 실행되었지만 위에서 얘기한 것 처럼 한 트랜잭션이 어떤 연산을 하려고 할때 다른 트랙잰션에서 unlock만 되어 있다면 수행이 가능하므로 2PLP를 준수했다고 본다. 
* 2PLP를 준수했다면 결국 병행처럼 보이는 스케쥴도 직렬이 가능하다라고 볼 수 있다.

![]({{site.url}}/assets/images/db64.PNG)

* 위의 예제는 그 전과 똑같이 병행처리고 lock 처리는 맞다. 그러나 2PLP가 아니다.
* 예를 들어 T2에서 lock(y)가 unlock(x) 뒤에 있기 때문이다.
* 즉, 첫 번재 unlock이전에 모든 lock이 먼저 일어나야 한다.



#### 3.2 Timestamp

* 타임 스탬프 순서 기법
  * 비직렬 트랜잭션을 타임 스탬프 순서에 의해 트랜잭션 직렬화
  * 로깅이 필요 없으므로 교착상태가 발생하지 않음
  * 로킹과 교착상태 탐지 비죵을 줄일 수 있음
  * 분산데이터베이스에서 활용 가능
* 타임 스탬프 순서
  * 트랜잭션을 유일하게 식별하는 식별자
  * 트랜잭션 시작 시간으로 간주 가능
  * 종류
    * 논리적 계수 : 계수기를 사용해서 트랜잭션이 들어 올 때마다 증가
    * 시스템 클록 : 시스템의 고유 시간

##### 3.2.1 타임 스탬프 순서 규칙

* 트랜잭션 Ti가 read(x)를 수행하려고 할 때, 
  * TS(Ti) < write_TS(x) 이면, read(x)를 거부하고, Ti 취소 + 복귀
  * TS(Ti) >= writ_TS(x) 이면, read(x)를 허용하고, read_TS(Ti)과 read_TS(x) 중 큰 것으로 선택
* 트랜잭션 Ti write(x)를 수행하려고 할 때, 
  * TS(Ti) < read_TS(x)이면, write(x)을 거부하고 Ti 취소+복귀
  * TS(Ti) < write_TS(x)이면, write(x)을 거부하고 Ti 취소+복귀
  * 그 외의 경우에는, write_TS(x)를 허용하고 write_TS(x) 값을 TS(Ti)로 고정



### 4. 회복 기법

* 트랜잭션이 실행되는 동안 재해나 실수에 의한 장애로부터 가장 가까운 정상 상태로 복귀하는 것

#### 4.1 주요 회복기법

* 로그 기법
  * 지연 갱신 기법
  * 즉기 갱신 기법
* 검사점 기반
* 그림자 페이지 사용
* 2 phase commit



##### 4.1.1 로그 기반 기법

![]({{site.url}}/assets/images/db65.PNG)



##### 4.1.2 검사점 기반

![]({{site.url}}/assets/images/db66.PNG)

* t1, t2, t3 : 회복 대상에서 제외
* t4, t5, t6 : 일단 undo 하고, t4는 c2 이후 부분 redo, t5, t6는 redo



##### 4.1.3 그림자 페이지 사용

![]({{site.url}}/assets/images/db67.PNG)

* 현재 테이블은 주기억 장치에 저장, 그림자 페이지 테이블을 디스크에 저장
* 트랜잭션 시작 시점에서 그림자 테이블 저장



##### 4.1.4 2 phase commit (2PC)

![]({{site.url}}/assets/images/db68.PNG)

* 조정자 : 분산 트랜잭션 참여자 명단 보유
* 참여자 : 트랜잭션 수행

* 2PC는 직렬성을 보장하는 통신 규약
* 각 트랜잭션은 lock과 unlock을 2단계로 발신함
* 신뢰도가 증가하지만, 오버헤드 증가
